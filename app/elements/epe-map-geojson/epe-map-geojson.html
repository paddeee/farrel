<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../../bower_components/polymer/polymer.html">

<dom-module id="epe-map-geojson">
    <template>
      <link rel="stylesheet" href="../../bower_components/leaflet.markercluster/dist/MarkerCluster.css" />
      <link rel="stylesheet" href="../../bower_components/leaflet.markercluster/dist/MarkerCluster.Default.css" />

      <style>

        :host {
          display: none;
        }

      </style>
    </template>
</dom-module>

<script src="../../bower_components/leaflet.markercluster/dist/leaflet.markercluster-src.js"></script>

<script>

  (function() {
    Polymer({

      is: 'epe-map-geojson',

      behaviors: [window.leafletMap.LeafletILayer],

      properties: {
        /**
         * data as geojson object
         *
         * @property data
         * @type Object
         */
        data: {
          type: Object,
          observer: '_dataChanged'
        },

        container: {
          type: Object,
          observer: '_containerChanged'
        },
        /**

         /**
         * The attribute `color` sets the stroke color.
         *
         * @attribute color
         * @type string
         */
        color: {
          type: String,
          value: '#03f'
        },

        /**
         * The attribute `weight` sets the stroke width in pixels.
         *
         * @attribute weight
         * @type number
         */
        weight: {
          type: Number,
          value: 2
        },

        /**
         * The attribute `opacity` sets the stroke opacity.
         *
         * @attribute opacity
         * @type number
         */
        opacity: {
          type: Number,
          value: 0.5
        },

        /**
         * The attribute `fill` sets the whether to fill the path with color. Set it to false to disable filling on polygons or circles.
         *
         * @attribute fill
         * @type boolean
         */
        fill: {
          type: Boolean,
          value: null
        },

        /**
         * The attribute `fill-color` sets the fill color.
         *
         * @attribute fill-color
         * @type string
         */
        fillColor: {
          type: String,
          value: null
        },

        /**
         * The attribute `fill-opacity` sets the fill opacity.
         *
         * @attribute fill-opacity
         * @type number
         */
        fillOpacity: {
          type: Number,
          value: 0.2
        },

        /**
         * The attribute `dash-array` sets a string that defines the stroke dash pattern. Doesn't work on canvas-powered layers (e.g. Android 2).
         *
         * @attribute dash-array
         * @type string
         */
        dashArray: {
          type: String,
          value: null
        },

        /**
         * The attribute `line-cap` defines the shape to be used at the end of the stroke.
         *
         * @attribute line-cap
         * @type string
         */
        lineCap: {
          type: String,
          value: null
        },

        /**
         * The attribute `line-join` sets the string that defines shape to be used at the corners of the stroke.
         *
         * @attribute line-join
         * @type string
         */
        lineJoin: {
          type: String,
          value: null
        },

        clusterLayer: {
          type: Object
        },

        markers: {
          type: Array,
          value: []
        },

        features: {
          type: Array,
          value: []
        },

        // Options to use for the Leaflet GeoJSON Layer
        geoJsonLayerOptions: {
          type: Object,
          value: null
        },

        //
        activeEvent: {
          type: String,
          observer: 'activeEventChanged'
        }
      },

      ready: function() {

        // Initialise a ClusterLayer
        this.clusterLayer = new window.L.MarkerClusterGroup({
          showCoverageOnHover: false,
          spiderfyOnMaxZoom: true
        });

        // Assign functions to the geoJsonLayerOptions Object
        this.geoJsonLayerOptions = {
          pointToLayer: this._pointToLayer.bind(this),
          onEachFeature: this._onEachFeature.bind(this),
          filter: this._filterFeature,
          style: this._setFeatureStyle.bind(this)
        };
      },

      // Function to pass to Leaflet to handle display of single point features on the map
      _pointToLayer: function(feature, latlng) {

        var marker = new window.L.Marker(latlng);

        // Need to pass an object into leaflet popup so will stringify and parse inside element on the
        // other side.
        var eventData = JSON.stringify(feature.properties);

        // ToDo: Set custom icons
        /*if (recordAttr.icon !== undefined) {
          var eventIcon = L.icon({
            iconUrl: recordAttr.icon,
            iconSize:     [100, 20], // size of the icon
            iconAnchor:   [22, 94], // point of the icon which will correspond to marker's location
            shadowAnchor: [4, 62],  // the same for the shadow
            popupAnchor:  [-3, -76] // point from which the popup should open relative to the iconAnchor
          });
          marker.setIcon(eventIcon);
        }

        // When a marker is clicked, update the fragment id, which will in turn update the timeline
        marker.on("click", function (e) {
          var i = _.indexOf(record.collection.models, record);
          window.location.hash = "#" + i.toString();
        });*/

        // Using ECMAScript 6 templates. Note ` character enclosing the value not '.
        // eventData is a stringified object that can be parsed into a JS Object inside epe-event-card.
        marker.bindPopup(`<epe-event-card event-data='${eventData}'></epe-event-card>`, {
          autoPan: false,
          keepInView: true,
          minWidth: 400,
          maxWidth: 400,
          offset: new window.L.point(230, -4),
          autoPanPadding: new window.L.point(230, 28)
        });

        this.clusterLayer.addLayer(marker);

        // Add marker to markers array so we can remove these from GeoJSON layer when clustering
        this.markers.push(marker);

        return marker;
      },

      // Function to pass to Leaflet to handle display of all features on the map
      _onEachFeature: function(feature, layer) {

        // Need to pass an object into leaflet popup so will stringify and parse inside element on the
        // other side.
        var eventData = JSON.stringify(feature.properties);

        layer.bindPopup(`<epe-event-card event-data='${eventData}'></epe-event-card>`, {
          autoPan: false,
            keepInView: true,
            minWidth: 400,
            maxWidth: 400,
            offset: new window.L.point(230, -4),
            autoPanPadding: new window.L.point(230, 28)
        });

        // Add feature to features array
        this.features.push(layer);
      },

      // Function that will be used to decide whether to show a feature or not.
      filterFeature: function(feature/*, layer*/) {

        // ToDo: Decide if we will use Leaflets filtering to hide features on map
        // ToDo: For now, just return all with a properties object
        return feature.properties;
      },

      // Set the style dynamically for a feature
      _setFeatureStyle: function(feature) {

        var stylesObject = {};

        // Set Style Depending on Geometry Category
        switch (feature.properties.type) {

          case 'Murder':
            stylesObject.color = this.color;
            stylesObject.weight = this.weight;
            stylesObject.opacity = this.opacity;
            stylesObject.fill = this.fill;
            stylesObject.fillColor = this.fillColor;
            stylesObject.fillOpacity = this.fillOpacity;
            stylesObject.dashArray = this.dashArray;
            stylesObject.lineCap = this.lineCap;
            stylesObject.lineJoin = this.lineJoin;
            break;

          case 'Arson':
            stylesObject.color = this.color;
            stylesObject.weight = this.weight;
            stylesObject.opacity = this.opacity;
            stylesObject.fill = this.fill;
            stylesObject.fillColor = this.fillColor;
            stylesObject.fillOpacity = this.fillOpacity;
            stylesObject.dashArray = this.dashArray;
            stylesObject.lineCap = this.lineCap;
            stylesObject.lineJoin = this.lineJoin;
            break;
        }

        // Set Style Depending on Geometry Category
        switch (feature.geometry.type) {

          case 'LineString':
            stylesObject.fill = false;
            break;

          case 'Polygon':
            stylesObject.fill = true;
            break;
        }

        return stylesObject;
      },

      // Fired by Leaflet
      _containerChanged: function() {
        if (this.container && this.data) {
          this._dataChanged();
        }
      },

      // Update marker info
      _dataChanged: function() {

        if (this.container && this.data) {

          this.clearMap();

          this.setUpLeafletCluster();

          this.setUpFeaturesLayer();

          // Add cluster and feature layers
          this.clusterLayer.addTo(this.container);
          this.geoJSONLayer.addTo(this.container);
        }
      },

      // Set up Clustering on Markers
      setUpLeafletCluster: function() {

        this.clusterLayer = new window.L.MarkerClusterGroup({
          showCoverageOnHover: false,
          spiderfyOnMaxZoom: true
        });
      },

      // Set up Layer for features other than markers
      setUpFeaturesLayer: function() {

        // Create a GeoJSON layer from data
        this.geoJSONLayer = window.L.geoJson(this.data, this.geoJsonLayerOptions);

        // Remove markers from GeoJSON layer as they are already on map in the cluster layer
        this.markers.forEach(function(marker) {
          this.geoJSONLayer.removeLayer(marker);
        }.bind(this));
      },

      // Delete markers and layers
      clearMap: function() {

        this.markers = [];

        if (this.container && this.geoJSONLayer) {
          this.container.removeLayer(this.geoJSONLayer);
        }

        if (this.container && this.clusterLayer) {
          this.container.removeLayer(this.clusterLayer);
        }
      },

      // OBSERVER ON ACTIVEEVENT
      activeEventChanged: function() {

        var $map = this.closest('#LeafletMap');
        var features = this.features;
        var clusterLayer = this.clusterLayer;
        var geoJSONLayer = this.geoJSONLayer;

        features.forEach(function(feature) {

          // If marker to jump to exists as marker on the map
          if (this.activeEvent.eventId === feature.feature.properties.id.toString()) {

            // If a marker
            if (feature.feature.geometry.type === 'Point') {

              if (clusterLayer.hasLayer(feature)) {

                // Pan and zoom into the cluster or just to a marker if zoomed in enough already
                clusterLayer.zoomToShowLayer(feature, function () {

                  // Open marker popup
                  feature.openPopup();
                });
              }

              // If a Line or Polygon
            } else {

              if (geoJSONLayer.hasLayer(feature)) {

                // Pan to feature
                $map.map.fitBounds(feature.getBounds());

                // Open marker popup
                feature.openPopup();
              }
            }
          }
        }.bind(this));
      }
    });
  })();
</script>
