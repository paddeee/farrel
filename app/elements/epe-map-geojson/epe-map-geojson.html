<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../../bower_components/polymer/polymer.html">

<dom-module id="epe-map-geojson">
    <template>
      <link rel="stylesheet" href="../../bower_components/leaflet.markercluster/dist/MarkerCluster.css" />
      <link rel="stylesheet" href="../../bower_components/leaflet.markercluster/dist/MarkerCluster.Default.css" />
      <link rel="stylesheet" href="../../styles/vendor/font-awesome/css/font-awesome.min.css" />
      <link rel="stylesheet" href="../../styles/vendor/leaflet/awesome-markers/leaflet.awesome-markers.css">
      <style>

        :host {
          display: none;
        }

      </style>
    </template>
</dom-module>

<script src="../../bower_components/leaflet.markercluster/dist/leaflet.markercluster-src.js"></script>
<script src="../../scripts/vendor/leaflet/awesome-markers/leaflet.awesome-markers.js"></script>

<script>

  (function() {
    Polymer({

      is: 'epe-map-geojson',

      behaviors: [window.leafletMap.LeafletILayer],

      properties: {
        /**
         * data as geojson object
         *
         * @property data
         * @type Object
         */
        data: {
          type: Object,
          observer: 'dataChanged'
        },

        container: {
          type: Object,
          observer: 'containerChanged'
        },
        /**

         /**
         * The attribute `color` sets the stroke color.
         *
         * @attribute color
         * @type string
         */
        color: {
          type: String,
          value: '#03f'
        },

        /**
         * The attribute `weight` sets the stroke width in pixels.
         *
         * @attribute weight
         * @type number
         */
        weight: {
          type: Number,
          value: 2
        },

        /**
         * The attribute `opacity` sets the stroke opacity.
         *
         * @attribute opacity
         * @type number
         */
        opacity: {
          type: Number,
          value: 0.5
        },

        /**
         * The attribute `fill` sets the whether to fill the path with color. Set it to false to disable filling on polygons or circles.
         *
         * @attribute fill
         * @type boolean
         */
        fill: {
          type: Boolean,
          value: null
        },

        /**
         * The attribute `fill-color` sets the fill color.
         *
         * @attribute fill-color
         * @type string
         */
        fillColor: {
          type: String,
          value: null
        },

        /**
         * The attribute `fill-opacity` sets the fill opacity.
         *
         * @attribute fill-opacity
         * @type number
         */
        fillOpacity: {
          type: Number,
          value: 0.2
        },

        /**
         * The attribute `dash-array` sets a string that defines the stroke dash pattern. Doesn't work on canvas-powered layers (e.g. Android 2).
         *
         * @attribute dash-array
         * @type string
         */
        dashArray: {
          type: String,
          value: null
        },

        /**
         * The attribute `line-cap` defines the shape to be used at the end of the stroke.
         *
         * @attribute line-cap
         * @type string
         */
        lineCap: {
          type: String,
          value: null
        },

        /**
         * The attribute `line-join` sets the string that defines shape to be used at the corners of the stroke.
         *
         * @attribute line-join
         * @type string
         */
        lineJoin: {
          type: String,
          value: null
        },

        clusterLayer: {
          type: Object
        },

        markers: {
          type: Array,
          value: []
        },

        features: {
          type: Array,
          value: []
        },

        // Options to use for the Leaflet GeoJSON Layer
        geoJsonLayerOptions: {
          type: Object,
          value: null
        },

        //
        activeEvent: {
          type: String,
          observer: 'activeEventChanged'
        },

        // Used so we can close a popup without resetting timeline when necessary
        activeEventExistsInFeatures: {
          type: Boolean,
          value: false
        }
      },

      ready: function() {

        // Initialise a ClusterLayer
        this.clusterLayer = new window.L.MarkerClusterGroup({
          showCoverageOnHover: false,
          spiderfyOnMaxZoom: true
        });

        // Assign functions to the geoJsonLayerOptions Object
        this.geoJsonLayerOptions = {
          pointToLayer: this.pointToLayer.bind(this),
          onEachFeature: this.onEachFeature.bind(this),
          filter: this.filterFeature
        };
      },

      // Function to pass to Leaflet to handle display of single point features on the map
      pointToLayer: function(feature, latlng) {

        var marker = new window.L.Marker(latlng);

        var markerIcon = L.AwesomeMarkers.icon({
          icon: 'map-pin',
          markerColor: 'orange',
          prefix: 'fa'
        });

        marker.setIcon(markerIcon);

        // Need to pass an object into leaflet popup so will stringify and parse inside element on the
        // other side.
        var eventData = JSON.stringify(feature.properties);

        this.clusterLayer.addLayer(marker);

        // Add marker to markers array so we can remove these from GeoJSON layer when clustering
        this.markers.push(marker);

        return marker;
      },

      // Function to pass to Leaflet to handle display of all features on the map
      onEachFeature: function(feature, layer) {

        // Need to pass an object into leaflet popup so will stringify and parse inside element on the
        // other side.
        var eventData = JSON.stringify(feature.properties);

        this.setFeatureStyle(layer, feature);

        layer.bindPopup(`<epe-event-card event-data='${eventData}'></epe-event-card>`, {
            autoPan: false,
            keepInView: true,
            minWidth: 400,
            maxWidth: 400,
            offset: new window.L.point(230, -4),
            autoPanPadding: new window.L.point(230, 28)
        });

        // Bind click event to marker so we can update TimeLine when a feature is selected
        layer.on('popupopen', this.popUpOpened.bind(this));

        // Bind click event to marker so we can update TimeLine when a feature is selected
        layer.on('popupclose', this.popUpClosed.bind(this));

        // Add feature to features array if it doesn't exist already
        this.features.push(layer);
      },

      // Function that will be used to decide whether to show a feature or not.
      filterFeature: function(feature/*, layer*/) {

        // ToDo: Decide if we will use Leaflets filtering to hide features on map
        // ToDo: For now, just return all with a properties object
        return feature.properties;
      },

      // Set the style dynamically for a feature
      setFeatureStyle: function(layer, feature) {

        var stylesObject = {};

        if (feature.properties.pointOfInterest) {

          // Set Style Depending on Geometry Category
          switch (feature.geometry.type) {

            case 'Point':
              this.setMarkerIcon(layer, feature, true);
              break;

            case 'LineString':
              stylesObject.fill = false;
              break;

            case 'Polygon':
              stylesObject.fill = true;
              break;
          }
          // Set custom icons
          /*if (recordAttr.icon !== undefined) {
           var eventIcon = L.icon({
           iconUrl: recordAttr.icon,
           iconSize:     [100, 20], // size of the icon
           iconAnchor:   [22, 94], // point of the icon which will correspond to marker's location
           shadowAnchor: [4, 62],  // the same for the shadow
           popupAnchor:  [-3, -76] // point from which the popup should open relative to the iconAnchor
           });
           marker.setIcon(eventIcon);
           }*/
        }

        // Set Style Depending on Geometry Category
        switch (feature.properties.type) {

          case 'Murder':
            stylesObject.color = this.color;
            stylesObject.weight = this.weight;
            stylesObject.opacity = this.opacity;
            stylesObject.fill = this.fill;
            stylesObject.fillColor = this.fillColor;
            stylesObject.fillOpacity = this.fillOpacity;
            stylesObject.dashArray = this.dashArray;
            stylesObject.lineCap = this.lineCap;
            stylesObject.lineJoin = this.lineJoin;
            break;

          case 'Arson':
            stylesObject.color = this.color;
            stylesObject.weight = this.weight;
            stylesObject.opacity = this.opacity;
            stylesObject.fill = this.fill;
            stylesObject.fillColor = this.fillColor;
            stylesObject.fillOpacity = this.fillOpacity;
            stylesObject.dashArray = this.dashArray;
            stylesObject.lineCap = this.lineCap;
            stylesObject.lineJoin = this.lineJoin;
            break;
        }

        // Set Style Depending on Geometry Category
        switch (feature.geometry.type) {

          case 'LineString':
            stylesObject.fill = false;
            break;

          case 'Polygon':
            stylesObject.fill = true;
            break;
        }

        return stylesObject;
      },

      // Set relevant marker icon
      setMarkerIcon: function(marker, feature, pointOfInterest, category) {

        // If point of Interest
        if (pointOfInterest) {

          var pointOfInterestMarker = L.AwesomeMarkers.icon({
            icon: 'info',
            markerColor: 'black',
            prefix: 'fa'
          });

          marker.setIcon(pointOfInterestMarker);
        }
      },

      // Fired by Leaflet
      containerChanged: function() {
        if (this.container && this.data) {
          this.dataChanged();
        }
      },

      // Update marker info
      dataChanged: function() {

        if (this.container && this.data) {

          this.clearMap();

          this.setUpLeafletCluster();

          this.setUpFeaturesLayer();

          // Add cluster and feature layers
          this.clusterLayer.addTo(this.container);
          this.geoJSONLayer.addTo(this.container);
        }
      },

      // Set up Clustering on Markers
      setUpLeafletCluster: function() {

        this.clusterLayer = new window.L.MarkerClusterGroup({
          showCoverageOnHover: false,
          spiderfyOnMaxZoom: true
        });
      },

      // Set up Layer for features other than markers
      setUpFeaturesLayer: function() {

        // Create a GeoJSON layer from data
        this.geoJSONLayer = window.L.geoJson(this.data, this.geoJsonLayerOptions);

        // Remove markers from GeoJSON layer as they are already on map in the cluster layer
        this.markers.forEach(function(marker) {
          this.geoJSONLayer.removeLayer(marker);
        }.bind(this));
      },

      // Delete markers and layers
      clearMap: function() {

        this.markers = [];

        this.features = [];

        if (this.container && this.geoJSONLayer) {
          this.container.removeLayer(this.geoJSONLayer);
        }

        if (this.container && this.clusterLayer) {
          this.container.removeLayer(this.clusterLayer);
        }
      },

      // OBSERVER ON ACTIVEEVENT
      activeEventChanged: function() {

        var $map = this.closest('#LeafletMap');
        var features = this.features;
        var clusterLayer = this.clusterLayer;
        var geoJSONLayer = this.geoJSONLayer;

        this.activeEventExistsInFeatures = false;
        this.isPointOfInterest = false;

        features.forEach(function(feature) {

          // If feature is a point of interest no tied to event
          if (feature.feature.properties.id === 'noEvent') {
            this.isPointOfInterest = true;
            return;
          }

          // If no selected event, close the popup
          if (this.activeEvent.eventId === '0' || feature.feature.properties.id === 'noEvent') {
            feature.closePopup();
            return;
          }

          // If marker to jump to exists as marker on the map
          if (this.activeEvent.eventId === feature.feature.properties.id.toString()) {

            // Hide No Locations event card
            this.fire('toggle-event-card-no-location', {
              activeEventId: this.activeEvent.eventId,
              show: false
            });

            // The active event exists in Map so reset this property
            this.activeEventExistsInFeatures = true;

            // If a marker
            if (feature.feature.geometry.type === 'Point') {

              if (clusterLayer.hasLayer(feature)) {

                // Pan and zoom into the cluster or just to a marker if zoomed in enough already
                clusterLayer.zoomToShowLayer(feature, function () {

                  // Open marker popup
                  feature.openPopup();
                });
              }

              // If a Line or Polygon
            } else {

              if (geoJSONLayer.hasLayer(feature)) {

                // Pan to feature
                $map.map.fitBounds(feature.getBounds());

                // Open marker popup
                feature.openPopup();
              }
            }
          }
        }.bind(this));

        // The active event doesn't exist in Map so show Event Card for No Location
        if (!this.activeEventExistsInFeatures && !this.isPointOfInterest) {

          // Close any popups
          this.features.forEach(function(layer) {
            if (layer._popup._isOpen) {
              layer.closePopup();
            }
          });

          // Show event card
          this.fire('toggle-event-card-no-location', {
            activeEventId: this.activeEvent.eventId,
            show: true
          });
        }
      },

      // When a popup is opened
      popUpOpened: function(data) {

        // if the event card has been opened
        if (data.target._popup._isOpen) {

          // Call mapEventSelected export action
          this.selectedRecordsActions.mapEventSelected({
            eventId: data.target.feature.properties.id
          });
        }
      },

      // When a popup is closed
      popUpClosed: function() {

        // Hack because data.target._popup._isOpen reports as true even though the method that fired is popupclose
        // Blame Leaflet. Async gives Leaflet chance to update this property for us to check below
        this.async(function() {

          var openPopups = this.features.filter(function(feature) {
            return feature._popup._isOpen === true;
          });

          if (!openPopups.length && this.activeEventExistsInFeatures) {

            // No popups so TimeLine needs to know
            this.selectedRecordsActions.mapEventSelected({
              eventId: '0'
            });
          }
        }, 1000);
      }
    });
  })();
</script>
