<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../../bower_components/polymer/polymer.html">

<dom-module id="epe-annotations">

  <script src="../../scripts/vendor/annotations/fabric.js"></script>

  <style>

    :host {
      position: relative;
      display: block;
      box-sizing: border-box;
    }

    .editor {
      position: fixed;
      right: 0;
      top: 0;
      bottom: 0;
      z-index: 1;
    }

    .content-wrapper > ::content {
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      overflow: hidden;
    }

  </style>

  <template>
    <epe-annotions-editor
      id="AnnotationsEditor"
      class="editor"
      show-editor="{{showEditor}}"
      hide-editor-stroke-width="[[hideEditorStrokeWidth]]"
      hide-editor-stroke-tools="[[hideEditorStrokeTools]]"
      hide-editor-fill-tools="[[hideEditorFillTools]]"
      selected-annotation="{{selectedAnnotation}}"></epe-annotions-editor>
    <div id="ContentWrapper" class="content-wrapper">
      <content id="AnnotationContent"></content>
    </div>
    <canvas id="Canvas"></canvas>
  </template>

</dom-module>
<script>
(function() {
  Polymer({
    is: 'epe-annotations',

    properties: {

      annotationType: {
        type: String,
        value: 'image'
      },

      annotationHeight: {
        type: Number,
        observer: 'setCanvasDimensions'
      },

      annotationWidth: {
        type: Number,
        observer: 'setCanvasDimensions'
      },

      // Keep record of curent width to use for scaling canvas
      currentAnnotationWidth: {
        type: Number,
        value: 0
      },

      defaultBrushColour: {
        type: String,
        value: 'rgb(231, 76, 60)'
      },

      defaultStrokeColour: {
        type: String,
        value: '#000'
      },

      defaultTextColour: {
        type: String,
        value: '#000'
      },

      defaultFillColour: {
        type: String,
        value: '#F55'
      },

      defaultHighlightStrokeColour: {
        type: String,
        value: '#EEFF41'
      },

      defaultHighlightFillColour: {
        type: String,
        value: '#FFFF00'
      },

      defaultLineColour: {
        type: String,
        value: 'rgb(231, 76, 60)'
      },

      // Whether annotations editor is shown
      showEditor: {
        type: Boolean
      },

      // Whether annotations editor stroke tools should be displayed
      hideEditorStrokeTools: {
        type: Boolean
      },

      // Whether annotations editor fill tools should be displayed
      hideEditorFillTools: {
        type: Boolean
      },

      // Current user selected annotation object
      selectedAnnotation: {
        type: Object,
        value: null
      }
    },

    // Element Lifecycle
    attached: function() {

      // because of shady DOM we have to assign the canvas a random ID otherwise fabric.js
      // finds only the first occurrence
      var elem = this.querySelector("canvas");
      elem.id = Math.random();
      this.canvas = new fabric.Canvas(elem.id);

      this.canvas.selection = false;

      this.canvas.on("object:added", this.canvasObjectAdded.bind(this));
      this.canvas.on("object:selected", this.canvasObjectSelected.bind(this));
      this.canvas.on("path:created", this.canvasPathCreated.bind(this));
      this.canvas.on("mouse:down", this.canvasMouseDown.bind(this));

    },

    // Called when a new drawing object has been added to the canvas.
    canvasObjectAdded: function(event) {

      var showEditorStrokeWidth = event.target.hasOwnProperty('stroke') || event.target.hasOwnProperty('txt');

      // If this has a path it is an object created by Text
      this.showEditor = true;
      this.hideEditorStrokeWidth = !showEditorStrokeWidth;
      this.hideEditorStrokeTools = !showEditorStrokeWidth;
      this.hideEditorFillTools = !!!event.target.hasOwnProperty('fill');
      this.selectedAnnotation = event.target;

      this.fire("annotation-object-added", {
        object: event.target
      });
    },

    // Called when a new drawing object has been added to the canvas.
    canvasObjectSelected: function(event) {

      var showEditorStrokeWidth = event.target.hasOwnProperty('stroke') || event.target.hasOwnProperty('text');

      this.showEditor = true;

      // If this has a path it is an object created by Free Draw
      if (event.target.path) {
        this.showEditor = true;
        this.hideEditorStrokeWidth = false;
        this.hideEditorStrokeTools = false;
        this.hideEditorFillTools = false;
        this.selectedAnnotation = event.target;
        this.selectedAnnotation.opacity = 1;

      } else {
        this.showEditor = true;
        this.hideEditorStrokeWidth = !showEditorStrokeWidth;
        this.hideEditorStrokeTools = !showEditorStrokeWidth;
        this.hideEditorFillTools = !!!event.target.hasOwnProperty('fill');
        this.selectedAnnotation = event.target;
      }

      this.fire("annotation-object-selected", {
        object: event.target
      });
    },

    // Is called internally when a new path has been created on the canvas.
    canvasPathCreated: function(event) {

      // Pass info through to annotations editor
      this.showEditor = true;
      this.hideEditorStrokeTools = true;
      this.hideEditorStrokeWidth = false;
      this.hideEditorFillTools = false;
      this.selectedAnnotation = event.path;
      this.selectedAnnotation.opacity = 1;

      this.fire("annotation-path-created");
    },

    canvasMouseDown: function(e) {
      this.fire("annotation-mouse-down");
    },

    // Gets the JSON representation of the drawing.
    toJSON: function() {
      return this.canvas.toJSON();
    },

    // Loads the JSON of a complete drawing and puts it on the canvas.
    loadJSON: function(drawing) {
      return this.canvas.loadFromJSON(drawing, this.canvas.renderAll.bind(this.canvas));
    },

    // Removes the drawing from the canvas.
    clear: function() {
      this.canvas.clear();
    },

    // Adds a drawing object to the current drawing on the canvas.
    /*addObject: function(object) {

      var canvas = this.canvas;

      fabric.util.enlivenObjects([object], function(objects) {

        var origRenderOnAddRemove = canvas.renderOnAddRemove;

        canvas.renderOnAddRemove = false;

        objects.forEach(function(object) {
          canvas.add(object);
        });

        canvas.renderOnAddRemove = origRenderOnAddRemove;

        canvas.renderAll();
      });
    },*/

    // Set the dimensions of the canvas
    setCanvasDimensions: function() {

      var scaleFactor;
      var currentZoom;

      if (this.canvas && this.annotationWidth) {

        // Get current zoom scale for the canvas
        currentZoom = this.canvas.getZoom();

        // Get the current scale factor
        scaleFactor = (this.annotationWidth / this.currentAnnotationWidth) * currentZoom;

        if(scaleFactor != 1) {

          this.canvas.setDimensions({
            width: this.annotationWidth,
            height: this.annotationHeight
          });

          // currentAnnotationWidth is set this is a resize so handle the zoom
          if (this.currentAnnotationWidth) {
            this.canvas.setZoom(scaleFactor);
            this.canvas.calcOffset();
            this.canvas.renderAll();
          }
        }

        // Keep record of current width for next time
        this.currentAnnotationWidth = this.annotationWidth;
      }
    },

    // Set canvas zoom level
    zoom: function(scaleFactor) {

      this.canvas.isDrawingMode = false;
      this.canvas.selection = false;

      this.canvas.setZoom(scaleFactor);
    },

    // Pan the canvas to specified x and y coordinates
    move: function(coords) {
      this.canvas.absolutePan(coords);
    },

    // Reset the canvas to original state
    reset: function() {

      // Clear the objects
      this.clear();

      // Pan to top left
      this.move({
        x: 0,
        y: 0
      });

      // Set the zoom back to 1
       this.canvas.setZoom(1);
    },

    // Free draw annotation
    freeDraw: function() {

      this.canvas.isDrawingMode = true;
      this.canvas.selection = true;
      this.canvas.freeDrawingBrush.color = this.defaultBrushColour;
      this.canvas.freeDrawingBrush.width = 5;
    },

    // Go into canvas selection mode
    selectAnnotations: function() {
      this.canvas.isDrawingMode = false;
      this.canvas.selection = true;
    },

    // Add a circle
    addCircle: function() {

      var circle = new fabric.Circle({
        radius: 30,
        stroke: this.defaultStrokeColour,
        fill: this.defaultFillColour,
        top: 100,
        left: 100,
        opacity: 0.8
      });

      this.canvas.isDrawingMode = false;
      this.canvas.selection = true;

      this.canvas.add(circle);
    },

    // Add a rectangle
    addRect: function() {

      var rect = new fabric.Rect({
        width: 50,
        height: 50,
        stroke: this.defaultStrokeColour,
        fill: this.defaultFillColour,
        top: 100,
        left: 100,
        opacity: 0.8
      });

      this.canvas.isDrawingMode = false;
      this.canvas.selection = true;

      this.canvas.add(rect);
    },

    // Add text
    addText: function() {

      var textObjext = new fabric.IText('Start typing..', {
        left: 100,
        top: 100,
        fill: this.defaultTextColour,
        fontFamily: 'Roboto, Noto'
      });

      this.canvas.isDrawingMode = false;
      this.canvas.selection = true;

      this.canvas.add(textObjext);

      // Automatically enter editing mode and select all text so user can just start typing
      this.canvas.setActiveObject(textObjext);
      textObjext.enterEditing();
      textObjext.selectAll();
    },

    // Add a rectangle with highlight colour
    highlightText: function() {

      var highlight = new fabric.Rect({
        width: 100,
        height: 20,
        fill: this.defaultHighlightFillColour,
        top: 100,
        left: 100,
        opacity: 0.6
      });

      this.canvas.isDrawingMode = false;
      this.canvas.selection = true;

      this.canvas.add(highlight);
    },

    // Add a line
    addLine: function() {

      var line = new fabric.Line([50, 150, 200, 150], {
        stroke: this.defaultLineColour,
        strokeWidth: 2
      });

      this.canvas.isDrawingMode = false;
      this.canvas.selection = true;

      this.canvas.add(line);
    }
  });
})();
</script>
