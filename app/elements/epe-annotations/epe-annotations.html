<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../../bower_components/polymer/polymer.html">

<dom-module id="epe-annotations">

  <script src="../../scripts/vendor/annotations/fabric.js"></script>

  <style>

    :host {
      position: relative;
      display: block;
      box-sizing: border-box;
    }

    .content-wrapper > ::content {
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      overflow: hidden;
    }

  </style>

  <template>
    <div id="ContentWrapper" class="content-wrapper">
      <content id="AnnotationContent"></content>
    </div>
    <canvas id="Canvas"></canvas>
  </template>

</dom-module>
<script>
(function() {
  Polymer({
    is: 'epe-annotations',

    properties: {

      annotationType: {
        type: String,
        value: 'image'
      },

      annotationHeight: {
        type: Number,
        observer: 'setCanvasDimensions'
      },

      annotationWidth: {
        type: Number,
        observer: 'setCanvasDimensions'
      },

      // Keep record of curent width to use for scaling canvas
      currentAnnotationWidth: {
        type: Number,
        value: 0
      }
    },

    // Element Lifecycle
    attached: function() {

      // because of shady DOM we have to assign the canvas a random ID otherwise fabric.js
      // finds only the first occurrence
      var elem = this.querySelector("canvas");
      elem.id = Math.random();
      this.canvas = new fabric.Canvas(elem.id);

      this.canvas.isDrawingMode = true;
      this.canvas.freeDrawingBrush.color = "red";
      this.canvas.freeDrawingBrush.width = 5;
      this.canvas.on("object:added", this._canvasObjectAdded.bind(this));
      this.canvas.on("path:created", this._canvasPathCreated.bind(this));
      this.canvas.on("mouse:down", this._canvasMouseDown.bind(this));

    },

    // Element Behavior
    /**
     * The `drawing-overlay-object-added` event is fired whenever a new object is added to the drawing.
     *
     * @event drawing-overlay-object-added
     * @detail {{object: Object}}
     */

    /**
     * The `drawing-overlay-path-created` event is fired whenever a path is created on the canvas.
     *
     * @event drawing-overlay-path-created
     * @detail {{object: Object}}
     */

    /**
     * The `drawing-overlay-mouse-down` event is fired whenever the mouse is pressed down on the canvas.
     *
     * @event drawing-overlay-mouse-down
     * @detail {{object: Object}}
     */

    // Is called internally when a new drawing object has been added to the canvas.
    _canvasObjectAdded: function(e) {
      this.fire("drawing-overlay-object-added", {object: e.target});
    },

    // Is called internally when a new path has been created on the canvas.
    _canvasPathCreated: function(e) {
      this.fire("drawing-overlay-path-created");
    },

    _canvasMouseDown: function(e) {
      this.fire("drawing-overlay-mouse-down");
    },

    // Gets the JSON representation of the drawing.
    toJSON: function() {
      return this.canvas.toJSON();
    },

    // Loads the JSON of a complete drawing and puts it on the canvas.
    loadJSON: function(drawing) {
      return this.canvas.loadFromJSON(drawing, this.canvas.renderAll.bind(this.canvas));
    },

    // Removes the drawing from the canvas.
    clear: function() {
      this.canvas.clear();
    },

    // Adds a drawing object to the current drawing on the canvas.
    addObject: function(object) {

      var canvas = this.canvas;

      fabric.util.enlivenObjects([object], function(objects) {

        var origRenderOnAddRemove = canvas.renderOnAddRemove;

        canvas.renderOnAddRemove = false;

        objects.forEach(function(object) {
          canvas.add(object);
        });

        canvas.renderOnAddRemove = origRenderOnAddRemove;

        canvas.renderAll();
      });
    },

    // Set the dimensions of the canvas
    setCanvasDimensions: function() {

      var scaleFactor;
      var currentZoom;

      if (this.canvas && this.annotationWidth) {

        // Get current zoom scale for the canvas
        currentZoom = this.canvas.getZoom();

        //
        scaleFactor = (this.annotationWidth / this.currentAnnotationWidth) * currentZoom;

        if(scaleFactor != 1) {

          this.canvas.setDimensions({
            width: this.annotationWidth,
            height: this.annotationHeight
          });

          // currentAnnotationWidth is set this is a resize so handle the zoom
          if (this.currentAnnotationWidth) {
            this.canvas.setZoom(scaleFactor);
            this.canvas.calcOffset();
            this.canvas.renderAll();
          }
        }

        // Keep record of current width for next time
        this.currentAnnotationWidth = this.annotationWidth;
      }
    },

    // Set canvas zoom level
    zoom: function(scaleFactor) {

      this.canvas.isDrawingMode = false;
      this.canvas.selection = false;

      this.canvas.setZoom(scaleFactor);
    }
  });
})();
</script>
